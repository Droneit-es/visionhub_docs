import { HandlerType } from 'mathjax-full/js/input/tex/MapHandler.js';
import Stack from 'mathjax-full/js/input/tex/Stack.js';
import StackItemFactory from 'mathjax-full/js/input/tex/StackItemFactory.js';
import { Tags } from 'mathjax-full/js/input/tex/Tags.js';
import { MmlNode } from 'mathjax-full/js/core/MmlTree/MmlNode.js';
import { ParseInput, ParseResult } from 'mathjax-full/js/input/tex/Types.js';
import ParseOptions from 'mathjax-full/js/input/tex/ParseOptions.js';
import { StackItem, EnvList } from 'mathjax-full/js/input/tex/StackItem.js';
import { OptionList } from 'mathjax-full/js/util/Options.js';
export default class TexParser {
    private _string;
    configuration: ParseOptions;
    macroCount: number;
    stack: Stack;
    i: number;
    currentCS: string;
    constructor(_string: string, env: EnvList, configuration: ParseOptions);
    get options(): OptionList;
    get itemFactory(): StackItemFactory;
    get tags(): Tags;
    set string(str: string);
    get string(): string;
    parse(kind: HandlerType, input: ParseInput): ParseResult;
    lookup(kind: HandlerType, symbol: string): any;
    contains(kind: HandlerType, symbol: string): boolean;
    toString(): string;
    Parse(): void;
    Push(arg: StackItem | MmlNode): void;
    PushAll(args: (StackItem | MmlNode)[]): void;
    mml(): MmlNode;
    convertDelimiter(c: string): string;
    getCodePoint(): string;
    nextIsSpace(): boolean;
    GetNext(): string;
    GetCS(): string;
    GetArgument(_name: string, noneOK?: boolean): string;
    GetBrackets(_name: string, def?: string): string;
    GetDelimiter(name: string, braceOK?: boolean): string;
    GetDimen(name: string): string;
    GetUpTo(_name: string, token: string): string;
    ParseArg(name: string): MmlNode;
    ParseUpTo(name: string, token: string): MmlNode;
    GetDelimiterArg(name: string): string;
    GetStar(): boolean;
    create(kind: string, ...rest: any[]): MmlNode;
}
